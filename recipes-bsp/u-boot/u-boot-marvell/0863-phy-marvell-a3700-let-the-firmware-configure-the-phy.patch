From 2bf290b5ea65f62006a920a011a7974c8500cad4 Mon Sep 17 00:00:00 2001
From: Grzegorz Jaszczyk <jaz@semihalf.com>
Date: Fri, 31 Aug 2018 10:55:38 +0200
Subject: [PATCH 0863/1200] phy: marvell: a3700: let the firmware configure the
 phy

Serdes lanes configuration are now available via SiP services in
firmware (firmware comphy driver exposes it's API via RT service).
Therefore take advantage and replace all comphy initialization with
appropriate SMC calls.

Change-Id: I96c6c8f107859253b316a0f015e4d7bb096338ba
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/59620
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Igal Liberman <igall@marvell.com>
---
 drivers/phy/marvell/Makefile       |   1 -
 drivers/phy/marvell/comphy_a3700.c | 776 +++--------------------------
 drivers/phy/marvell/comphy_a3700.h | 196 +-------
 drivers/phy/marvell/comphy_mux.c   | 124 -----
 drivers/phy/marvell/comphy_priv.h  |  11 -
 5 files changed, 72 insertions(+), 1036 deletions(-)
 delete mode 100644 drivers/phy/marvell/comphy_mux.c

diff --git a/drivers/phy/marvell/Makefile b/drivers/phy/marvell/Makefile
index f181505389..86d1c44e49 100644
--- a/drivers/phy/marvell/Makefile
+++ b/drivers/phy/marvell/Makefile
@@ -3,6 +3,5 @@
 #
 
 obj-$(CONFIG_MVEBU_COMPHY_SUPPORT) += comphy_core.o
-obj-$(CONFIG_MVEBU_COMPHY_SUPPORT) += comphy_mux.o
 obj-$(CONFIG_ARMADA_3700) += comphy_a3700.o
 obj-$(CONFIG_ARMADA_8K) += comphy_cp110.o
diff --git a/drivers/phy/marvell/comphy_a3700.c b/drivers/phy/marvell/comphy_a3700.c
index a4d4586d57..40b042d90f 100644
--- a/drivers/phy/marvell/comphy_a3700.c
+++ b/drivers/phy/marvell/comphy_a3700.c
@@ -14,126 +14,41 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+/* Firmware related definitions used for SMC calls */
+#define MV_SIP_COMPHY_POWER_ON	0x82000001
+
+#define COMPHY_FW_MODE_FORMAT(mode, invert)	((mode) << 12 | (invert) << 0)
+
+#define COMPHY_SATA_MODE	0x1
+#define COMPHY_SGMII_MODE	0x2	/* SGMII 1G */
+#define COMPHY_HS_SGMII_MODE	0x3	/* SGMII 2.5G */
+#define COMPHY_USB3H_MODE	0x4
+#define COMPHY_USB3D_MODE	0x5
+#define COMPHY_PCIE_MODE	0x6
+#define COMPHY_RXAUI_MODE	0x7
+#define COMPHY_XFI_MODE		0x8
+#define COMPHY_SFI_MODE		0x9
+#define COMPHY_USB3_MODE	0xa
+#define COMPHY_AP_MODE		0xb
+
 #define A3700_LANE_MAX_NUM	3
 
-struct sgmii_phy_init_data_fix {
-	u16 addr;
-	u16 value;
-};
+static int comphy_smc(u32 function_id, u32 lane, u32 mode)
+{
+#ifndef CONFIG_MVEBU_PALLADIUM
+	struct pt_regs pregs = {0};
 
-/*
- * In PHY mux initialization, comphy_mux_init() takes it for granted that
- * lanes' phy select bits in selector base register are ordered by lane number;
- * but for a3700, lane1 phy select bit is before lane0 in selector base
- * register as below, so it requires the mapping from the nominal lane index
- * defined in FS to the actual lane index by PHY Selector register order.
- *
- * RD00183FCh (00000011h) - PHY Selector
- *      bit 0: PCIE_GBE0_SEL -PHY Lane 1 Mode Select, 0h: GbE0 1h: PCIe
- *      bit 4: USB_GBE1_SEL -PHY Lane 0 Mode Select, 0h: GbE1 1h: USB
- *      bit 8: USB_SATA_SEL -PHY Lane 2 Mode Select, 0h: SATA 1h: USB
- */
-struct a3700_comphy_lane_mux_map {
-	u32 lane_num;		/* the nominal lane index defined in FS  */
-	u32 phy_select_num;	/* the actual lane index in PHY Selector Reg */
-};
-
-struct a3700_comphy_lane_mux_map lane_mux_map[A3700_LANE_MAX_NUM] = {
-/* Lane 0 */ {0, 1},
-/* Lane 1 */ {1, 0},
-/* Lane 2 */ {2, 2}
-};
-
-struct comphy_mux_data a3700_comphy_mux_data[] = {
-/* Lane 0 */ {5, {{COMPHY_TYPE_UNCONNECTED, 0x0}, {COMPHY_TYPE_SGMII1, 0x0},
-			{COMPHY_TYPE_USB3, 0x1}, {COMPHY_TYPE_USB3_HOST0, 0x1},
-			{COMPHY_TYPE_USB3_DEVICE, 0x1} } },
-/* Lane 1 */ {3, {{COMPHY_TYPE_UNCONNECTED, 0x0}, {COMPHY_TYPE_SGMII0, 0x0},
-			{COMPHY_TYPE_PEX0, 0x1} } },
-/* Lane 2 */ {4, {{COMPHY_TYPE_UNCONNECTED, 0x0}, {COMPHY_TYPE_SATA0, 0x0} } },
-};
-
-/* Changes to 40M1G25 mode data required for running 40M3G125 init mode */
-static struct sgmii_phy_init_data_fix sgmii_phy_init_fix[] = {
-	{0x005, 0x07CC}, {0x015, 0x0000}, {0x01B, 0x0000}, {0x01D, 0x0000},
-	{0x01E, 0x0000}, {0x01F, 0x0000}, {0x020, 0x0000}, {0x021, 0x0030},
-	{0x026, 0x0888}, {0x04D, 0x0152}, {0x04F, 0xA020}, {0x050, 0x07CC},
-	{0x053, 0xE9CA}, {0x055, 0xBD97}, {0x071, 0x3015}, {0x076, 0x03AA},
-	{0x07C, 0x0FDF}, {0x0C2, 0x3030}, {0x0C3, 0x8000}, {0x0E2, 0x5550},
-	{0x0E3, 0x12A4}, {0x0E4, 0x7D00}, {0x0E6, 0x0C83}, {0x101, 0xFCC0},
-	{0x104, 0x0C10}
-};
-
-/* 40M1G25 mode init data */
-static u16 sgmii_phy_init[512] = {
-	/* 0       1       2       3       4       5       6       7 */
-	/*-----------------------------------------------------------*/
-	/* 8       9       A       B       C       D       E       F */
-	0x3110, 0xFD83, 0x6430, 0x412F, 0x82C0, 0x06FA, 0x4500, 0x6D26,	/* 00 */
-	0xAFC0, 0x8000, 0xC000, 0x0000, 0x2000, 0x49CC, 0x0BC9, 0x2A52,	/* 08 */
-	0x0BD2, 0x0CDE, 0x13D2, 0x0CE8, 0x1149, 0x10E0, 0x0000, 0x0000,	/* 10 */
-	0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x4134, 0x0D2D, 0xFFFF,	/* 18 */
-	0xFFE0, 0x4030, 0x1016, 0x0030, 0x0000, 0x0800, 0x0866, 0x0000,	/* 20 */
-	0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,	/* 28 */
-	0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* 30 */
-	0x0000, 0x0000, 0x000F, 0x6A62, 0x1988, 0x3100, 0x3100, 0x3100,	/* 38 */
-	0x3100, 0xA708, 0x2430, 0x0830, 0x1030, 0x4610, 0xFF00, 0xFF00,	/* 40 */
-	0x0060, 0x1000, 0x0400, 0x0040, 0x00F0, 0x0155, 0x1100, 0xA02A,	/* 48 */
-	0x06FA, 0x0080, 0xB008, 0xE3ED, 0x5002, 0xB592, 0x7A80, 0x0001,	/* 50 */
-	0x020A, 0x8820, 0x6014, 0x8054, 0xACAA, 0xFC88, 0x2A02, 0x45CF,	/* 58 */
-	0x000F, 0x1817, 0x2860, 0x064F, 0x0000, 0x0204, 0x1800, 0x6000,	/* 60 */
-	0x810F, 0x4F23, 0x4000, 0x4498, 0x0850, 0x0000, 0x000E, 0x1002,	/* 68 */
-	0x9D3A, 0x3009, 0xD066, 0x0491, 0x0001, 0x6AB0, 0x0399, 0x3780,	/* 70 */
-	0x0040, 0x5AC0, 0x4A80, 0x0000, 0x01DF, 0x0000, 0x0007, 0x0000,	/* 78 */
-	0x2D54, 0x00A1, 0x4000, 0x0100, 0xA20A, 0x0000, 0x0000, 0x0000,	/* 80 */
-	0x0000, 0x0000, 0x0000, 0x7400, 0x0E81, 0x1000, 0x1242, 0x0210,	/* 88 */
-	0x80DF, 0x0F1F, 0x2F3F, 0x4F5F, 0x6F7F, 0x0F1F, 0x2F3F, 0x4F5F,	/* 90 */
-	0x6F7F, 0x4BAD, 0x0000, 0x0000, 0x0800, 0x0000, 0x2400, 0xB651,	/* 98 */
-	0xC9E0, 0x4247, 0x0A24, 0x0000, 0xAF19, 0x1004, 0x0000, 0x0000,	/* A0 */
-	0x0000, 0x0013, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* A8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* B0 */
-	0x0000, 0x0000, 0x0000, 0x0060, 0x0000, 0x0000, 0x0000, 0x0000,	/* B8 */
-	0x0000, 0x0000, 0x3010, 0xFA00, 0x0000, 0x0000, 0x0000, 0x0003,	/* C0 */
-	0x1618, 0x8200, 0x8000, 0x0400, 0x050F, 0x0000, 0x0000, 0x0000,	/* C8 */
-	0x4C93, 0x0000, 0x1000, 0x1120, 0x0010, 0x1242, 0x1242, 0x1E00,	/* D0 */
-	0x0000, 0x0000, 0x0000, 0x00F8, 0x0000, 0x0041, 0x0800, 0x0000,	/* D8 */
-	0x82A0, 0x572E, 0x2490, 0x14A9, 0x4E00, 0x0000, 0x0803, 0x0541,	/* E0 */
-	0x0C15, 0x0000, 0x0000, 0x0400, 0x2626, 0x0000, 0x0000, 0x4200,	/* E8 */
-	0x0000, 0xAA55, 0x1020, 0x0000, 0x0000, 0x5010, 0x0000, 0x0000,	/* F0 */
-	0x0000, 0x0000, 0x5000, 0x0000, 0x0000, 0x0000, 0x02F2, 0x0000,	/* F8 */
-	0x101F, 0xFDC0, 0x4000, 0x8010, 0x0110, 0x0006, 0x0000, 0x0000,	/*100 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*108 */
-	0x04CF, 0x0000, 0x04CF, 0x0000, 0x04CF, 0x0000, 0x04C6, 0x0000,	/*110 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*118 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*120 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*128 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*130 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*138 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*140 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*148 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*150 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*158 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*160 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*168 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*170 */
-	0x0000, 0x0000, 0x0000, 0x00F0, 0x08A2, 0x3112, 0x0A14, 0x0000,	/*178 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*180 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*188 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*190 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*198 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1A0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1A8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1B0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1B8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1C0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1C8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1D0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1D8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1E0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1E8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1F0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000	/*1F8 */
-};
+	pregs.regs[0] = function_id;
+	pregs.regs[1] = lane;
+	pregs.regs[2] = mode;
+
+	smc_call(&pregs);
+
+	return pregs.regs[0];
+#else
+	return 1;
+#endif
+}
 
 /*
  * comphy_poll_reg
@@ -161,188 +76,29 @@ static u32 comphy_poll_reg(void *addr, u32 val, u32 mask, u32 timeout,
 	return 0;
 }
 
-/*
- * comphy_pcie_power_up
- *
- * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
- */
-static int comphy_pcie_power_up(u32 speed, u32 invert)
-{
-	int	ret;
-
-	debug_enter();
-
-	/*
-	 * 1. Enable max PLL.
-	 */
-	reg_set16((void __iomem *)LANE_CFG1_ADDR(PCIE),
-		  bf_use_max_pll_rate, 0);
-
-	/*
-	 * 2. Select 20 bit SERDES interface.
-	 */
-	reg_set16((void __iomem *)GLOB_CLK_SRC_LO_ADDR(PCIE),
-		  bf_cfg_sel_20b, 0);
-
-	/*
-	 * 3. Force to use reg setting for PCIe mode
-	 */
-	reg_set16((void __iomem *)MISC_REG1_ADDR(PCIE),
-		  bf_sel_bits_pcie_force, 0);
-
-	/*
-	 * 4. Change RX wait
-	 */
-	reg_set16((void __iomem *)PWR_MGM_TIM1_ADDR(PCIE), 0x10C, 0xFFFF);
-
-	/*
-	 * 5. Enable idle sync
-	 */
-	reg_set16((void __iomem *)UNIT_CTRL_ADDR(PCIE),
-		  0x60 | rb_idle_sync_en, 0xFFFF);
-
-	/*
-	 * 6. Enable the output of 100M/125M/500M clock
-	 */
-	reg_set16((void __iomem *)MISC_REG0_ADDR(PCIE),
-		  0xA00D | rb_clk500m_en | rb_clk100m_125m_en, 0xFFFF);
-
-	/*
-	 * 7. Enable TX, PCIE global register, 0xd0074814, it is done in
-	 * PCI-E driver
-	 */
-
-	/*
-	 * 8. Check crystal jumper setting and program the Power and PLL
-	 *    Control accordingly
-	 */
-	if (get_ref_clk() == 40) {
-		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(PCIE),
-			  0xFC63, 0xFFFF); /* 40 MHz */
-	} else {
-		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(PCIE),
-			  0xFC62, 0xFFFF); /* 25 MHz */
-	}
-
-	/*
-	 * 9. Override Speed_PLL value and use MAC PLL
-	 */
-	reg_set16((void __iomem *)KVCO_CAL_CTRL_ADDR(PCIE),
-		  0x0040 | rb_use_max_pll_rate, 0xFFFF);
-
-	/*
-	 * 10. Check the Polarity invert bit
-	 */
-	if (invert & COMPHY_POLARITY_TXD_INVERT) {
-		reg_set16((void __iomem *)SYNC_PATTERN_ADDR(PCIE),
-			  phy_txd_inv, 0);
-	}
-
-	if (invert & COMPHY_POLARITY_RXD_INVERT) {
-		reg_set16((void __iomem *)SYNC_PATTERN_ADDR(PCIE),
-			  phy_rxd_inv, 0);
-	}
-
-	/*
-	 * 11. Release SW reset
-	 */
-	reg_set16((void __iomem *)GLOB_PHY_CTRL0_ADDR(PCIE),
-		  rb_mode_core_clk_freq_sel | rb_mode_pipe_width_32,
-		  bf_soft_rst | bf_mode_refdiv);
-
-	/* Wait for > 55 us to allow PCLK be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert PCLK enabled */
-	ret = comphy_poll_reg((void *)LANE_STAT1_ADDR(PCIE),	/* address */
-			      rb_txdclk_pclk_en,		/* value */
-			      rb_txdclk_pclk_en,		/* mask */
-			      PLL_LOCK_TIMEOUT,			/* timeout */
-			      POLL_16B_REG);			/* 16bit */
-	if (ret == 0)
-		printf("Failed to lock PCIe PLL\n");
-
-	debug_exit();
-
-	/* Return the status of the PLL */
-	return ret;
-}
-
 /*
  * comphy_sata_power_up
  *
  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
  */
-static int comphy_sata_power_up(u32 invert)
+static int comphy_sata_power_up(u32 invert, u32 lane)
 {
 	int	ret;
-	u32	data = 0;
 
 	debug_enter();
 
 	/*
-	 * 0. Check the Polarity invert bits
-	 */
-	if (invert & COMPHY_POLARITY_TXD_INVERT)
-		data |= bs_txd_inv;
-
-	if (invert & COMPHY_POLARITY_RXD_INVERT)
-		data |= bs_rxd_inv;
-	reg_set((void __iomem *)rh_vsreg_addr,
-		vphy_sync_pattern_reg, 0xFFFFFFFF);
-	reg_set((void __iomem *)rh_vsreg_data, data, bs_txd_inv | bs_rxd_inv);
-
-	/*
-	 * 1. Select 40-bit data width width
-	 */
-	reg_set((void __iomem *)rh_vsreg_addr, vphy_loopback_reg0, 0xFFFFFFFF);
-	reg_set((void __iomem *)rh_vsreg_data, 0x800, bs_phyintf_40bit);
-
-	/*
-	 * 2. Select reference clock and PHY mode (SATA)
-	 */
-	reg_set((void __iomem *)rh_vsreg_addr, vphy_power_reg0, 0xFFFFFFFF);
-	if (get_ref_clk() == 40) {
-		reg_set((void __iomem *)rh_vsreg_data,
-			0x3, 0x00FF); /* 40 MHz */
-	} else {
-		reg_set((void __iomem *)rh_vsreg_data,
-			0x1, 0x00FF); /* 25 MHz */
-	}
-
-	/*
-	 * 3. Use maximum PLL rate (no power save)
-	 */
-	reg_set((void __iomem *)rh_vsreg_addr, vphy_calctl_reg, 0xFFFFFFFF);
-	reg_set((void __iomem *)rh_vsreg_data,
-		bs_max_pll_rate, bs_max_pll_rate);
-
-	/*
-	 * 4. Reset reserved bit (??)
-	 */
-	reg_set((void __iomem *)rh_vsreg_addr, vphy_reserve_reg, 0xFFFFFFFF);
-	reg_set((void __iomem *)rh_vsreg_data, 0, bs_phyctrl_frm_pin);
-
-	/*
-	 * 5. Set vendor-specific configuration (??)
+	 * Set vendor-specific configuration (??).
+	 * It was done in the middle of comphy initialization but test shows
+	 * that moving it before strict comphy init works ok. Thanks to that the
+	 * comphy init can be done with pure comphy range access, not touching
+	 * ahci range.
 	 */
 	reg_set((void __iomem *)rh_vs0_a, vsata_ctrl_reg, 0xFFFFFFFF);
 	reg_set((void __iomem *)rh_vs0_d, bs_phy_pu_pll, bs_phy_pu_pll);
 
-	/* Wait for > 55 us to allow PLL be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert SATA PLL enabled */
-	reg_set((void __iomem *)rh_vsreg_addr, vphy_loopback_reg0, 0xFFFFFFFF);
-	ret = comphy_poll_reg((void *)rh_vsreg_data,	/* address */
-			      bs_pll_ready_tx,		/* value */
-			      bs_pll_ready_tx,		/* mask */
-			      PLL_LOCK_TIMEOUT,		/* timeout */
-			      POLL_32B_REG);		/* 32bit */
-	if (ret == 0)
-		printf("Failed to lock SATA PLL\n");
-
-	debug_exit();
+	ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+			 COMPHY_FW_MODE_FORMAT(COMPHY_SATA_MODE, invert));
 
 	return ret;
 }
@@ -352,7 +108,8 @@ static int comphy_sata_power_up(u32 invert)
  *
  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
  */
-static int comphy_usb3_power_up(u32 speed, u32 invert)
+static int comphy_usb3_power_up(u32 speed, u32 invert, u32 lane,
+				bool indirect_reg_access)
 {
 	int	ret;
 
@@ -370,132 +127,10 @@ static int comphy_usb3_power_up(u32 speed, u32 invert)
 	reg_set((void __iomem *)USB3_CTRPUL_VAL_REG,
 		0x8 << 24, rb_usb3_ctr_100ns);
 
+	ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+			 COMPHY_FW_MODE_FORMAT(COMPHY_USB3_MODE, invert));
 
-	/* 0xd005c300 = 0x1001 */
-	/* set PRD_TXDEEMPH (3.5db de-emph) */
-	reg_set16((void __iomem *)LANE_CFG0_ADDR(USB3), 0x1, 0xFF);
-
-	/*
-	 * Set BIT0: enable transmitter in high impedance mode
-	 * Set BIT[3:4]: delay 2 clock cycles for HiZ off latency
-	 * Set BIT6: Tx detect Rx at HiZ mode
-	 * Unset BIT15: set to 0 to set USB3 De-emphasize level to -3.5db
-	 *              together with bit 0 of COMPHY_REG_LANE_CFG0_ADDR
-	 *		register
-	 */
-	reg_set16((void __iomem *)LANE_CFG1_ADDR(USB3),
-		  TX_DET_RX_MODE | GEN2_TX_DATA_DLY_DEFT |
-		  TX_ELEC_IDLE_MODE_EN,
-		  PRD_TXDEEMPH1_MASK | TX_DET_RX_MODE | GEN2_TX_DATA_DLY_MASK |
-		  TX_ELEC_IDLE_MODE_EN);
-
-	/* 0xd005c310 = 0x93: set Spread Spectrum Clock Enabled  */
-	reg_set16((void __iomem *)LANE_CFG4_ADDR(USB3),
-		  bf_spread_spectrum_clock_en, 0x80);
-
-	/*
-	 * set Override Margining Controls From the MAC: Use margining signals
-	 * from lane configuration
-	 */
-	reg_set16((void __iomem *)TEST_MODE_CTRL_ADDR(USB3),
-		  rb_mode_margin_override, 0xFFFF);
-
-	/* set Lane-to-Lane Bundle Clock Sampling Period = per PCLK cycles */
-	/* set Mode Clock Source = PCLK is generated from REFCLK */
-	reg_set16((void __iomem *)GLOB_CLK_SRC_LO_ADDR(USB3), 0x0, 0xFF);
-
-	/* set G2 Spread Spectrum Clock Amplitude at 4K */
-	reg_set16((void __iomem *)GEN2_SETTING_2_ADDR(USB3), g2_tx_ssc_amp,
-		  0xF000);
-
-	/*
-	 * unset G3 Spread Spectrum Clock Amplitude & set G3 TX and RX Register
-	 * Master Current Select
-	 */
-	reg_set16((void __iomem *)GEN2_SETTING_3_ADDR(USB3), 0x0, 0xFFFF);
-
-	/*
-	 * 3. Check crystal jumper setting and program the Power and PLL
-	 * Control accordingly
-	 */
-	if (get_ref_clk() == 40) {
-		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(USB3), 0xFCA3,
-			  0xFFFF); /* 40 MHz */
-	} else {
-		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(USB3), 0xFCA2,
-			  0xFFFF); /* 25 MHz */
-	}
-
-	/*
-	 * 4. Change RX wait
-	 */
-	reg_set16((void __iomem *)PWR_MGM_TIM1_ADDR(USB3), 0x10C, 0xFFFF);
-
-	/*
-	 * 5. Enable idle sync
-	 */
-	reg_set16((void __iomem *)UNIT_CTRL_ADDR(USB3), 0x60 | rb_idle_sync_en,
-		  0xFFFF);
-
-	/*
-	 * 6. Enable the output of 500M clock
-	 */
-	reg_set16((void __iomem *)MISC_REG0_ADDR(USB3), 0xA00D | rb_clk500m_en,
-		  0xFFFF);
-
-	/*
-	 * 7. Set 20-bit data width
-	 */
-	reg_set16((void __iomem *)DIG_LB_EN_ADDR(USB3), 0x0400, 0xFFFF);
-
-	/*
-	 * 8. Override Speed_PLL value and use MAC PLL
-	 */
-	reg_set16((void __iomem *)KVCO_CAL_CTRL_ADDR(USB3),
-		  0x0040 | rb_use_max_pll_rate, 0xFFFF);
-
-	/*
-	 * 9. Check the Polarity invert bit
-	 */
-	if (invert & COMPHY_POLARITY_TXD_INVERT) {
-		reg_set16((void __iomem *)SYNC_PATTERN_ADDR(USB3),
-			  phy_txd_inv, 0);
-	}
-
-	if (invert & COMPHY_POLARITY_RXD_INVERT) {
-		reg_set16((void __iomem *)SYNC_PATTERN_ADDR(USB3),
-			  phy_rxd_inv, 0);
-	}
-
-	/* 10. Set max speed generation to USB3.0 5Gbps */
-	reg_set16((void __iomem *)SYNC_MASK_GEN_REG(USB3),
-		  PHY_GEN_USB3_5G, PHY_GEN_MAX_MASK);
-
-	/* 11. Set capacitor value for FFE gain peaking to 0xF */
-	reg_set16((void __iomem *)GEN3_SETTINGS_3(USB3),
-		  PHY_GEN_FFE_CAP_SEL_VALUE, PHY_GEN_FFE_CAP_SEL_MASK);
-
-	/*
-	 * 12. Release SW reset
-	 */
-	reg_set16((void __iomem *)GLOB_PHY_CTRL0_ADDR(USB3),
-		  rb_mode_core_clk_freq_sel | rb_mode_pipe_width_32 | 0x20,
-		  0xFFFF);
-
-	/* Wait for > 55 us to allow PCLK be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert PCLK enabled */
-	ret = comphy_poll_reg((void *)LANE_STAT1_ADDR(USB3),	/* address */
-			      rb_txdclk_pclk_en,		/* value */
-			      rb_txdclk_pclk_en,		/* mask */
-			      PLL_LOCK_TIMEOUT,			/* timeout */
-			      POLL_16B_REG);			/* 16bit */
-	if (ret == 0)
-		printf("Failed to lock USB3 PLL\n");
-
-	/*
-	 * No matter host mode and device mode, it works with Hard ID detection.
+	/* No matter host mode and device mode, it works with Hard ID detection
 	 * Unset DP and DM pulldown for USB2 Device mode
 	 */
 	reg_set((void __iomem *)USB2_OTG_PHY_CTRL_ADDR, 0x0,
@@ -662,234 +297,9 @@ static int comphy_emmc_power_up(void)
 }
 
 /*
- * comphy_sgmii_power_up
- *
- * return:
+ * comphy_dedicated_phys_init initialize the dedicated PHYs
+ * - not muxed SerDes lanes e.g. UTMI PHY
  */
-static void comphy_sgmii_phy_init(u32 lane, u32 speed)
-{
-	const int fix_arr_sz = ARRAY_SIZE(sgmii_phy_init_fix);
-	int addr, fix_idx;
-	u16 val;
-
-	fix_idx = 0;
-	for (addr = 0; addr < 512; addr++) {
-		/*
-		 * All PHY register values are defined in full for 3.125Gbps
-		 * SERDES speed. The values required for 1.25 Gbps are almost
-		 * the same and only few registers should be "fixed" in
-		 * comparison to 3.125 Gbps values. These register values are
-		 * stored in "sgmii_phy_init_fix" array.
-		 */
-		if ((speed != COMPHY_SPEED_1_25G) &&
-		    (sgmii_phy_init_fix[fix_idx].addr == addr)) {
-			/* Use new value */
-			val = sgmii_phy_init_fix[fix_idx].value;
-			if (fix_idx < fix_arr_sz)
-				fix_idx++;
-		} else {
-			val = sgmii_phy_init[addr];
-		}
-
-		phy_write16(lane, addr, val, 0xFFFF);
-	}
-}
-
-/*
- * comphy_sgmii_power_up
- *
- * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
- */
-static int comphy_sgmii_power_up(u32 lane, u32 speed, u32 invert)
-{
-	int	ret;
-
-	debug_enter();
-
-	/*
-	 * 1. Configure PHY to SATA/SAS mode by setting pin PIN_PIPE_SEL=0
-	 */
-	reg_set((void __iomem *)COMPHY_SEL_ADDR, 0, rf_compy_select(lane));
-
-	/*
-	 * 2. Reset PHY by setting PHY input port PIN_RESET=1.
-	 * 3. Set PHY input port PIN_TX_IDLE=1, PIN_PU_IVREF=1 to keep
-	 *    PHY TXP/TXN output to idle state during PHY initialization
-	 * 4. Set PHY input port PIN_PU_PLL=0, PIN_PU_RX=0, PIN_PU_TX=0.
-	 */
-	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-		rb_pin_reset_comphy | rb_pin_tx_idle | rb_pin_pu_iveref,
-		rb_pin_reset_core | rb_pin_pu_pll |
-		rb_pin_pu_rx | rb_pin_pu_tx);
-
-	/*
-	 * 5. Release reset to the PHY by setting PIN_RESET=0.
-	 */
-	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-		0, rb_pin_reset_comphy);
-
-	/*
-	 * 7. Set PIN_PHY_GEN_TX[3:0] and PIN_PHY_GEN_RX[3:0] to decide
-	 *    COMPHY bit rate
-	 */
-	if (speed == COMPHY_SPEED_3_125G) { /* 3.125 GHz */
-		reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-			(0x8 << rf_gen_rx_sel_shift) |
-			(0x8 << rf_gen_tx_sel_shift),
-			rf_gen_rx_select | rf_gen_tx_select);
-
-	} else if (speed == COMPHY_SPEED_1_25G) { /* 1.25 GHz */
-		reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-			(0x6 << rf_gen_rx_sel_shift) |
-			(0x6 << rf_gen_tx_sel_shift),
-			rf_gen_rx_select | rf_gen_tx_select);
-	} else {
-		printf("Unsupported COMPHY speed!\n");
-		return 0;
-	}
-
-	/*
-	 * 8. Wait 1mS for bandgap and reference clocks to stabilize;
-	 *    then start SW programming.
-	 */
-	mdelay(10);
-
-	/* 9. Program COMPHY register PHY_MODE */
-	phy_write16(lane, PHY_PWR_PLL_CTRL_ADDR,
-		    PHY_MODE_SGMII << rf_phy_mode_shift, rf_phy_mode_mask);
-
-	/*
-	 * 10. Set COMPHY register REFCLK_SEL to select the correct REFCLK
-	 *     source
-	 */
-	phy_write16(lane, PHY_MISC_REG0_ADDR, 0, rb_ref_clk_sel);
-
-	/*
-	 * 11. Set correct reference clock frequency in COMPHY register
-	 *     REF_FREF_SEL.
-	 */
-	if (get_ref_clk() == 40) {
-		phy_write16(lane, PHY_PWR_PLL_CTRL_ADDR,
-			    0x4 << rf_ref_freq_sel_shift, rf_ref_freq_sel_mask);
-	} else {
-		/* 25MHz */
-		phy_write16(lane, PHY_PWR_PLL_CTRL_ADDR,
-			    0x1 << rf_ref_freq_sel_shift, rf_ref_freq_sel_mask);
-	}
-
-	/* 12. Program COMPHY register PHY_GEN_MAX[1:0] */
-	/*
-	 * This step is mentioned in the flow received from verification team.
-	 * However the PHY_GEN_MAX value is only meaningful for other
-	 * interfaces (not SGMII). For instance, it selects SATA speed
-	 * 1.5/3/6 Gbps or PCIe speed  2.5/5 Gbps
-	 */
-
-	/*
-	 * 13. Program COMPHY register SEL_BITS to set correct parallel data
-	 *     bus width
-	 */
-	/* 10bit */
-	phy_write16(lane, PHY_DIG_LB_EN_ADDR, 0, rf_data_width_mask);
-
-	/*
-	 * 14. As long as DFE function needs to be enabled in any mode,
-	 *     COMPHY register DFE_UPDATE_EN[5:0] shall be programmed to 0x3F
-	 *     for real chip during COMPHY power on.
-	 */
-	/*
-	 * The step 14 exists (and empty) in the original initialization flow
-	 * obtained from the verification team. According to the functional
-	 * specification DFE_UPDATE_EN already has the default value 0x3F
-	 */
-
-	/*
-	 * 15. Program COMPHY GEN registers.
-	 *     These registers should be programmed based on the lab testing
-	 *     result to achieve optimal performance. Please contact the CEA
-	 *     group to get the related GEN table during real chip bring-up.
-	 *     We only requred to run though the entire registers programming
-	 *     flow defined by "comphy_sgmii_phy_init" when the REF clock is
-	 *     40 MHz. For REF clock 25 MHz the default values stored in PHY
-	 *     registers are OK.
-	 */
-	debug("Running C-DPI phy init %s mode\n",
-	      speed == COMPHY_SPEED_3_125G ? "2G5" : "1G");
-	if (get_ref_clk() == 40)
-		comphy_sgmii_phy_init(lane, speed);
-
-	/*
-	 * 16. [Simulation Only] should not be used for real chip.
-	 *     By pass power up calibration by programming EXT_FORCE_CAL_DONE
-	 *     (R02h[9]) to 1 to shorten COMPHY simulation time.
-	 */
-	/*
-	 * 17. [Simulation Only: should not be used for real chip]
-	 *     Program COMPHY register FAST_DFE_TIMER_EN=1 to shorten RX
-	 *     training simulation time.
-	 */
-
-	/*
-	 * 18. Check the PHY Polarity invert bit
-	 */
-	if (invert & COMPHY_POLARITY_TXD_INVERT)
-		phy_write16(lane, PHY_SYNC_PATTERN_ADDR, phy_txd_inv, 0);
-
-	if (invert & COMPHY_POLARITY_RXD_INVERT)
-		phy_write16(lane, PHY_SYNC_PATTERN_ADDR, phy_rxd_inv, 0);
-
-	/*
-	 * 19. Set PHY input ports PIN_PU_PLL, PIN_PU_TX and PIN_PU_RX to 1
-	 *     to start PHY power up sequence. All the PHY register
-	 *     programming should be done before PIN_PU_PLL=1. There should be
-	 *     no register programming for normal PHY operation from this point.
-	 */
-	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-		rb_pin_pu_pll | rb_pin_pu_rx | rb_pin_pu_tx,
-		rb_pin_pu_pll | rb_pin_pu_rx | rb_pin_pu_tx);
-
-	/*
-	 * 20. Wait for PHY power up sequence to finish by checking output ports
-	 *     PIN_PLL_READY_TX=1 and PIN_PLL_READY_RX=1.
-	 */
-	ret = comphy_poll_reg((void *)COMPHY_PHY_STAT1_ADDR(lane), /* address */
-			      rb_pll_ready_tx | rb_pll_ready_rx, /* value */
-			      rb_pll_ready_tx | rb_pll_ready_rx, /* mask */
-			      PLL_LOCK_TIMEOUT,			/* timeout */
-			      POLL_32B_REG);			/* 32bit */
-	if (ret == 0)
-		printf("Failed to lock PLL for SGMII PHY %d\n", lane);
-
-	/*
-	 * 21. Set COMPHY input port PIN_TX_IDLE=0
-	 */
-	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-		0x0, rb_pin_tx_idle);
-
-	/*
-	 * 22. After valid data appear on PIN_RXDATA bus, set PIN_RX_INIT=1.
-	 *     to start RX initialization. PIN_RX_INIT_DONE will be cleared to
-	 *     0 by the PHY. After RX initialization is done, PIN_RX_INIT_DONE
-	 *     will be set to 1 by COMPHY. Set PIN_RX_INIT=0 after
-	 *     PIN_RX_INIT_DONE= 1.
-	 *     Please refer to RX initialization part for details.
-	 */
-	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane), rb_phy_rx_init,
-		0x0);
-
-	ret = comphy_poll_reg((void *)COMPHY_PHY_STAT1_ADDR(lane), /* address */
-			      rb_rx_init_done,			/* value */
-			      rb_rx_init_done,			/* mask */
-			      PLL_LOCK_TIMEOUT,		/* timeout */
-			      POLL_32B_REG);			/* 32bit */
-	if (ret == 0)
-		printf("Failed to init RX of SGMII PHY %d\n", lane);
-
-	debug_exit();
-
-	return ret;
-}
-
 void comphy_dedicated_phys_init(void)
 {
 	int node, usb32, ret = 1;
@@ -950,70 +360,13 @@ void comphy_dedicated_phys_init(void)
 	debug_exit();
 }
 
-static int comphy_a3700_get_phy_select_num(u32 lane_num, u32 *phy_select_num)
-{
-	u32 i;
-
-	for (i = 0; i < A3700_LANE_MAX_NUM; i++) {
-		if (lane_num == lane_mux_map[i].lane_num) {
-			*phy_select_num = lane_mux_map[i].phy_select_num;
-			return 0;
-		}
-	}
-
-	debug("No lane %d in the lane mux map table!\n", lane_num);
-	return 1;
-}
-
-static void comphy_a3700_mux_init(struct chip_serdes_phy_config *chip_cfg,
-				  struct comphy_map *serdes_map)
-{
-	u32 lane, phy_select_num;
-	u32 comphy_max_count = chip_cfg->comphy_lanes_count;
-	struct comphy_mux_data ordered_mux_data[A3700_LANE_MAX_NUM];
-	struct comphy_map ordered_serdes_map[A3700_LANE_MAX_NUM];
-
-	debug_enter();
-
-	/*
-	 * In PHY mux initialization, comphy_mux_init() takes it for granted
-	 * that lanes' phy select bits in selector base register are ordered by
-	 * lane number; but for a3700, lane1 phy select bit is before lane0 in
-	 * selector base register as below, so mux data and serdes map need
-	 * to be re-ordered to align with the lane index order in PHY Selector
-	 * register.
-	 *
-	 * RD00183FCh (00000011h) - PHY Selector
-	 *      bit 0: PCIE_GBE0_SEL -PHY Lane 1 Mode Select, 0h: GbE0 1h: PCIe
-	 *      bit 4: USB_GBE1_SEL -PHY Lane 0 Mode Select, 0h: GbE1 1h: USB
-	 *      bit 8: USB_SATA_SEL -PHY Lane 2 Mode Select, 0h: SATA 1h: USB
-	 */
-	memset(ordered_mux_data, 0, sizeof(ordered_mux_data));
-	memset(ordered_serdes_map, 0, sizeof(ordered_serdes_map));
-	for (lane = 0; lane < comphy_max_count; lane++) {
-		if (comphy_a3700_get_phy_select_num(lane, &phy_select_num))
-			return;
-		memcpy(&ordered_mux_data[phy_select_num],
-		       &a3700_comphy_mux_data[lane],
-		       sizeof(struct comphy_mux_data));
-		memcpy(&ordered_serdes_map[phy_select_num],
-		       serdes_map + lane,
-		       sizeof(struct comphy_map));
-	}
-
-	chip_cfg->mux_data = ordered_mux_data;
-	comphy_mux_init(chip_cfg, ordered_serdes_map,
-			(void __iomem *)COMPHY_SEL_ADDR);
-
-	debug_exit();
-}
-
 int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 		      struct comphy_map *serdes_map)
 {
 	struct comphy_map *comphy_map;
 	u32 comphy_max_count = chip_cfg->comphy_lanes_count;
 	u32 lane, ret = 0;
+	u32 mode = 0, fw_format = 0;
 
 	debug_enter();
 
@@ -1022,9 +375,6 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 		return 1;
 	}
 
-	/* PHY mux initialize */
-	comphy_a3700_mux_init(chip_cfg, serdes_map);
-
 	for (lane = 0, comphy_map = serdes_map; lane < comphy_max_count;
 	     lane++, comphy_map++) {
 		debug("Initialize serdes number %d\n", lane);
@@ -1037,25 +387,41 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 			break;
 
 		case COMPHY_TYPE_PEX0:
-			ret = comphy_pcie_power_up(comphy_map->speed,
-						   comphy_map->invert);
+			fw_format = COMPHY_FW_MODE_FORMAT(COMPHY_PCIE_MODE,
+							  comphy_map->invert);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+					 fw_format);
 			break;
 
 		case COMPHY_TYPE_USB3:
 		case COMPHY_TYPE_USB3_HOST0:
 		case COMPHY_TYPE_USB3_DEVICE:
+
 			ret = comphy_usb3_power_up(comphy_map->speed,
-						   comphy_map->invert);
+						   comphy_map->invert,
+						   lane,
+						   (lane == 2) ? true : false);
 			break;
 
 		case COMPHY_TYPE_SGMII0:
 		case COMPHY_TYPE_SGMII1:
-			ret = comphy_sgmii_power_up(lane, comphy_map->speed,
-						    comphy_map->invert);
+			if (comphy_map->speed == COMPHY_SPEED_1_25G)
+				mode = COMPHY_SGMII_MODE;
+			else if (comphy_map->speed == COMPHY_SPEED_3_125G)
+				mode = COMPHY_HS_SGMII_MODE;
+			else
+				printf("Unsupported COMPHY speed!\n");
+
+			fw_format = COMPHY_FW_MODE_FORMAT(mode,
+							  comphy_map->invert);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+					 fw_format);
+
 			break;
 
 		case COMPHY_TYPE_SATA0:
-			ret = comphy_sata_power_up(comphy_map->invert);
+			ret = comphy_sata_power_up(comphy_map->invert, lane);
+
 			break;
 
 		default:
@@ -1064,7 +430,7 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 			ret = 1;
 			break;
 		}
-		if (ret == 0)
+		if (ret != 0)
 			printf("PLL is not locked - Failed to initialize lane %d\n",
 			       lane);
 	}
diff --git a/drivers/phy/marvell/comphy_a3700.h b/drivers/phy/marvell/comphy_a3700.h
index 466197785b..645cf5faa3 100644
--- a/drivers/phy/marvell/comphy_a3700.h
+++ b/drivers/phy/marvell/comphy_a3700.h
@@ -11,198 +11,22 @@
 
 #define MVEBU_REG(offs)			((uintptr_t)MVEBU_REGISTER(offs))
 
-#define DEFAULT_REFCLK_MHZ		25
-#define PLL_SET_DELAY_US		600
 #define PLL_LOCK_TIMEOUT		1000
 #define POLL_16B_REG			1
 #define POLL_32B_REG			0
 
 /*
- * COMPHY SB definitions
+ * USB definitions
  */
-#define COMPHY_SEL_ADDR			MVEBU_REG(0x0183FC)
-#define rf_compy_select(lane)		(0x1 << ((lane) <= 1 ? (1 - (lane)) : \
-						 (lane)) * 4)
-
-#define COMPHY_PHY_CFG1_ADDR(lane)	MVEBU_REG(0x018300 + \
-						  (1 - (lane)) * 0x28)
-#define rb_pin_pu_iveref		BIT(1)
-#define rb_pin_reset_core		BIT(11)
-#define rb_pin_reset_comphy		BIT(12)
-#define rb_pin_pu_pll			BIT(16)
-#define rb_pin_pu_rx			BIT(17)
-#define rb_pin_pu_tx			BIT(18)
-#define rb_pin_tx_idle			BIT(19)
-#define rf_gen_rx_sel_shift		22
-#define rf_gen_rx_select		(0x0F << rf_gen_rx_sel_shift)
-#define rf_gen_tx_sel_shift		26
-#define rf_gen_tx_select		(0x0F << rf_gen_tx_sel_shift)
-#define rb_phy_rx_init			BIT(30)
-
-#define COMPHY_PHY_STAT1_ADDR(lane)	MVEBU_REG(0x018318 + \
-						  (1 - (lane)) * 0x28)
-#define rb_rx_init_done			BIT(0)
-#define rb_pll_ready_rx			BIT(2)
-#define rb_pll_ready_tx			BIT(3)
-
-/*
- * PCIe/USB/SGMII definitions
- */
-#define PCIEPHY_BASE			MVEBU_REG(0x01F000)
-#define PCIEPHY_SHFT			2
-
 #define USB32_BASE			MVEBU_REG(0x050000) /* usb3 device */
-#define USB32H_BASE			MVEBU_REG(0x058000) /* usb3 host */
-#define USB3PHY_BASE			MVEBU_REG(0x05C000)
 #define USB2PHY_BASE			MVEBU_REG(0x05D000)
 #define USB2PHY2_BASE			MVEBU_REG(0x05F000)
-#define USB32_CTRL_BASE			MVEBU_REG(0x05D800)
-#define USB3PHY_SHFT			2
-
-#define SGMIIPHY_BASE(l)	(l == 1 ? PCIEPHY_BASE : USB3PHY_BASE)
-#define SGMIIPHY_ADDR(l, a)	(((a & 0x00007FF) * 2) | SGMIIPHY_BASE(l))
-
-#define phy_read16(l, a)	read16((void __iomem *)SGMIIPHY_ADDR(l, a))
-#define phy_write16(l, a, data, mask)	\
-	reg_set16((void __iomem *)SGMIIPHY_ADDR(l, a), data, mask)
-
-/* units */
-#define PCIE				1
-#define USB3				2
-
-#define PHY_BASE(unit)		((unit == PCIE) ? PCIEPHY_BASE : USB3PHY_BASE)
-#define PHY_SHFT(unit)		((unit == PCIE) ? PCIEPHY_SHFT : USB3PHY_SHFT)
-
-/* bit definition for USB32_CTRL_BASE (USB32 Control Mode) */
-#define usb32_ctrl_id_mode		BIT(0)
-#define usb32_ctrl_soft_id		BIT(1)
-#define usb32_ctrl_int_mode		BIT(4)
-
-
-#define PHY_PWR_PLL_CTRL_ADDR	0x01	/* for phy_read16 and phy_write16 */
-#define PWR_PLL_CTRL_ADDR(unit)		\
-	(PHY_PWR_PLL_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rf_phy_mode_shift		5
-#define rf_phy_mode_mask		(0x7 << rf_phy_mode_shift)
-#define rf_ref_freq_sel_shift		0
-#define rf_ref_freq_sel_mask		(0x1F << rf_ref_freq_sel_shift)
-#define PHY_MODE_SGMII			0x4
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_KVCO_CAL_CTRL_ADDR	0x02
-#define KVCO_CAL_CTRL_ADDR(unit)	\
-	(PHY_REG_KVCO_CAL_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rb_use_max_pll_rate		BIT(12)
-#define rb_force_calibration_done	BIT(9)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_DIG_LB_EN_ADDR		0x23
-#define DIG_LB_EN_ADDR(unit)		\
-	(PHY_DIG_LB_EN_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rf_data_width_shift		10
-#define rf_data_width_mask		(0x3 << rf_data_width_shift)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_SYNC_PATTERN_ADDR		0x24
-#define SYNC_PATTERN_ADDR(unit)		\
-	(PHY_SYNC_PATTERN_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define phy_txd_inv			BIT(10)
-#define phy_rxd_inv			BIT(11)
-
-#define PHY_SYNC_MASK_GEN_REG		0x25
-#define SYNC_MASK_GEN_REG(unit)		\
-	(PHY_SYNC_MASK_GEN_REG * PHY_SHFT(unit) + PHY_BASE(unit))
-#define PHY_GEN_MAX_OFFSET		10
-#define PHY_GEN_MAX_MASK		(3 << PHY_GEN_MAX_OFFSET)
-#define PHY_GEN_USB3_5G			(1 << PHY_GEN_MAX_OFFSET)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_UNIT_CTRL_ADDR		0x48
-#define UNIT_CTRL_ADDR(unit)		\
-	(PHY_REG_UNIT_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rb_idle_sync_en			BIT(12)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_GEN2_SETTINGS_2		0x3e
-#define GEN2_SETTING_2_ADDR(unit)	\
-	(PHY_REG_GEN2_SETTINGS_2 * PHY_SHFT(unit) + PHY_BASE(unit))
-#define g2_tx_ssc_amp			BIT(14)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_GEN2_SETTINGS_3		0x3f
-#define GEN2_SETTING_3_ADDR(unit)	\
-	(PHY_REG_GEN2_SETTINGS_3 * PHY_SHFT(unit) + PHY_BASE(unit))
-
-/* for phy_read16 and phy_write16 */
-#define PHY_MISC_REG0_ADDR		0x4f
-#define MISC_REG0_ADDR(unit)		\
-	(PHY_MISC_REG0_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rb_clk100m_125m_en		BIT(4)
-#define rb_clk500m_en			BIT(7)
-#define rb_ref_clk_sel			BIT(10)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_IFACE_REF_CLK_CTRL_ADDR		0x51
-#define UNIT_IFACE_REF_CLK_CTRL_ADDR(unit)	\
-	(PHY_REG_IFACE_REF_CLK_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rb_ref1m_gen_div_force		BIT(8)
-#define rf_ref1m_gen_div_value_shift	0
-#define rf_ref1m_gen_div_value_mask	(0xFF << rf_ref1m_gen_div_value_shift)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_ERR_CNT_CONST_CTRL_ADDR	0x6A
-#define UNIT_ERR_CNT_CONST_CTRL_ADDR(unit) \
-	(PHY_REG_ERR_CNT_CONST_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rb_fast_dfe_enable		BIT(13)
-
-#define MISC_REG1_ADDR(u)		(0x73 * PHY_SHFT(u) + PHY_BASE(u))
-#define bf_sel_bits_pcie_force		BIT(15)
-
-#define PHY_REG_GEN3_SETTINGS_3		0x112
-#define GEN3_SETTINGS_3(u)	\
-	(PHY_REG_GEN3_SETTINGS_3 * PHY_SHFT(u) + PHY_BASE(u))
-#define PHY_GEN_FFE_CAP_SEL_MASK	0xF
-#define PHY_GEN_FFE_CAP_SEL_VALUE	0xF
-
-#define PHY_REG_LANE_CFG0_ADDR		0x180
-#define LANE_CFG0_ADDR(u)	\
-	(PHY_REG_LANE_CFG0_ADDR * PHY_SHFT(u) + PHY_BASE(u))
-#define PHY_REG_LANE_CFG1_ADDR		0x181
-#define LANE_CFG1_ADDR(u)	\
-	(PHY_REG_LANE_CFG1_ADDR * PHY_SHFT(u) + PHY_BASE(u))
-#define PRD_TXDEEMPH1_MASK		BIT(15)
-#define bf_use_max_pll_rate		BIT(9)
-#define TX_DET_RX_MODE			BIT(6)
-#define GEN2_TX_DATA_DLY_MASK		(BIT(3) | BIT(4))
-#define GEN2_TX_DATA_DLY_DEFT		(2 << 3)
-#define TX_ELEC_IDLE_MODE_EN		BIT(0)
-/* 0x5c310 = 0x93 (set BIT7) */
-#define LANE_CFG4_ADDR(u)		(0x188 * PHY_SHFT(u) + PHY_BASE(u))
-#define bf_spread_spectrum_clock_en	BIT(7)
-
-#define LANE_STAT1_ADDR(u)		(0x183 * PHY_SHFT(u) + PHY_BASE(u))
-#define rb_txdclk_pclk_en		BIT(0)
-
-#define GLOB_PHY_CTRL0_ADDR(u)		(0x1c1 * PHY_SHFT(u) + PHY_BASE(u))
-#define bf_soft_rst			BIT(0)
-#define bf_mode_refdiv			0x30
-#define rb_mode_core_clk_freq_sel	BIT(9)
-#define rb_mode_pipe_width_32		BIT(3)
-
-#define TEST_MODE_CTRL_ADDR(u)		(0x1c2 * PHY_SHFT(u) + PHY_BASE(u))
-#define rb_mode_margin_override		BIT(2)
-
-#define GLOB_CLK_SRC_LO_ADDR(u)		(0x1c3 * PHY_SHFT(u) + PHY_BASE(u))
-#define bf_cfg_sel_20b			BIT(15)
-
-#define PWR_MGM_TIM1_ADDR(u)		(0x1d0 * PHY_SHFT(u) + PHY_BASE(u))
 
 #define USB3_CTRPUL_VAL_REG		(0x20 + USB32_BASE)
 #define USB3_TOP_INT_STATUS_REG		(0xd8 + USB32_BASE)
 #define vbus_int_state			BIT(5)
 #define USB3_TOP_INT_ENABLE_REG		(0xdc + USB32_BASE)
 #define vbus_int_enable			BIT(5)
-#define USB3H_CTRPUL_VAL_REG		(0x3454 + USB32H_BASE)
 #define rb_usb3_ctr_100ns		0xff000000
 
 #define USB2_OTG_PHY_CTRL_ADDR		(0x820 + USB2PHY_BASE)
@@ -259,27 +83,9 @@
  */
 #define AHCI_BASE			MVEBU_REG(0xE0000)
 
-#define rh_vsreg_addr			(AHCI_BASE + 0x178)
-#define rh_vsreg_data			(AHCI_BASE + 0x17C)
 #define rh_vs0_a			(AHCI_BASE + 0xA0)
 #define rh_vs0_d			(AHCI_BASE + 0xA4)
 
-#define vphy_sync_pattern_reg		0x224
-#define bs_txd_inv			BIT(10)
-#define bs_rxd_inv			BIT(11)
-
-#define vphy_loopback_reg0		0x223
-#define bs_phyintf_40bit		0x0C00
-#define bs_pll_ready_tx			0x10
-
-#define vphy_power_reg0			0x201
-
-#define vphy_calctl_reg			0x202
-#define bs_max_pll_rate			BIT(12)
-
-#define vphy_reserve_reg		0x0e
-#define bs_phyctrl_frm_pin		BIT(13)
-
 #define vsata_ctrl_reg			0x00
 #define bs_phy_pu_pll			BIT(6)
 
diff --git a/drivers/phy/marvell/comphy_mux.c b/drivers/phy/marvell/comphy_mux.c
deleted file mode 100644
index 10dfba0c6b..0000000000
--- a/drivers/phy/marvell/comphy_mux.c
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Copyright (C) 2015-2016 Marvell International Ltd.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <asm/io.h>
-
-#include "comphy_priv.h"
-
-/*
- * comphy_mux_check_config()
- * description: this function passes over the COMPHY lanes and check if the type
- *              is valid for specific lane. If the type is not valid,
- *              the function update the struct and set the type of the lane as
- *              COMPHY_TYPE_UNCONNECTED
- */
-static void comphy_mux_check_config(struct comphy_mux_data *mux_data,
-		struct comphy_map *comphy_map_data, int comphy_max_lanes)
-{
-	struct comphy_mux_options *mux_opt;
-	int lane, opt, valid;
-
-	debug_enter();
-
-	for (lane = 0; lane < comphy_max_lanes;
-	     lane++, comphy_map_data++, mux_data++) {
-		/* Don't check ignored COMPHYs */
-		if (comphy_map_data->type == COMPHY_TYPE_IGNORE)
-			continue;
-
-		mux_opt = mux_data->mux_values;
-		for (opt = 0, valid = 0; opt < mux_data->max_lane_values;
-		     opt++, mux_opt++) {
-			if (mux_opt->type == comphy_map_data->type) {
-				valid = 1;
-				break;
-			}
-		}
-		if (valid == 0) {
-			debug("lane number %d, had invalid type %d\n",
-			      lane, comphy_map_data->type);
-			debug("set lane %d as type %d\n", lane,
-			      COMPHY_TYPE_UNCONNECTED);
-			comphy_map_data->type = COMPHY_TYPE_UNCONNECTED;
-		} else {
-			debug("lane number %d, has type %d\n",
-			      lane, comphy_map_data->type);
-		}
-	}
-
-	debug_exit();
-}
-
-static u32 comphy_mux_get_mux_value(struct comphy_mux_data *mux_data,
-				    u32 type, int lane)
-{
-	struct comphy_mux_options *mux_opt;
-	int opt;
-	u32 value = 0;
-
-	debug_enter();
-
-	mux_opt = mux_data->mux_values;
-	for (opt = 0 ; opt < mux_data->max_lane_values; opt++, mux_opt++) {
-		if (mux_opt->type == type) {
-			value = mux_opt->mux_value;
-			break;
-		}
-	}
-
-	debug_exit();
-
-	return value;
-}
-
-static void comphy_mux_reg_write(struct comphy_mux_data *mux_data,
-				 struct comphy_map *comphy_map_data,
-				 int comphy_max_lanes,
-				 void __iomem *selector_base, u32 bitcount)
-{
-	u32 lane, value, offset, mask;
-
-	debug_enter();
-
-	for (lane = 0; lane < comphy_max_lanes;
-	     lane++, comphy_map_data++, mux_data++) {
-		if (comphy_map_data->type == COMPHY_TYPE_IGNORE)
-			continue;
-
-		offset = lane * bitcount;
-		mask = (((1 << bitcount) - 1) << offset);
-		value = (comphy_mux_get_mux_value(mux_data,
-						  comphy_map_data->type,
-						  lane) << offset);
-		reg_set(selector_base, value, mask);
-	}
-
-	debug_exit();
-}
-
-void comphy_mux_init(struct chip_serdes_phy_config *chip_cfg,
-		     struct comphy_map *comphy_map_data,
-		     void __iomem *selector_base)
-{
-	struct comphy_mux_data *mux_data;
-	u32 mux_bitcount;
-	u32 comphy_max_lanes;
-
-	debug_enter();
-
-	comphy_max_lanes = chip_cfg->comphy_lanes_count;
-	mux_data = chip_cfg->mux_data;
-	mux_bitcount = chip_cfg->comphy_mux_bitcount;
-
-	/* check if the configuration is valid */
-	comphy_mux_check_config(mux_data, comphy_map_data, comphy_max_lanes);
-	/* Init COMPHY selectors */
-	comphy_mux_reg_write(mux_data, comphy_map_data, comphy_max_lanes,
-			     selector_base, mux_bitcount);
-
-	debug_exit();
-}
diff --git a/drivers/phy/marvell/comphy_priv.h b/drivers/phy/marvell/comphy_priv.h
index f2ccf4606d..889d88b33c 100644
--- a/drivers/phy/marvell/comphy_priv.h
+++ b/drivers/phy/marvell/comphy_priv.h
@@ -22,16 +22,6 @@
 #define MAX_LANE_OPTIONS			10
 #define MAX_UTMI_PHY_COUNT			3
 
-struct comphy_mux_options {
-	u32 type;
-	u32 mux_value;
-};
-
-struct comphy_mux_data {
-	u32 max_lane_values;
-	struct comphy_mux_options mux_values[MAX_LANE_OPTIONS];
-};
-
 struct comphy_map {
 	u32 type;
 	u32 speed;
@@ -41,7 +31,6 @@ struct comphy_map {
 };
 
 struct chip_serdes_phy_config {
-	struct comphy_mux_data *mux_data;
 	int (*ptr_comphy_chip_init)(struct chip_serdes_phy_config *,
 				    struct comphy_map *);
 	int (*rx_training)(struct chip_serdes_phy_config *, u32);
-- 
2.22.0

